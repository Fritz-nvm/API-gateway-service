import redis.asyncio as redis
from typing import Optional, Tuple
from app.core.config import settings
import os

# Note: We assume the Redis client will be connected during app startup.


class IdempotencyService:
    """Service for handling idempotency using Redis (R3.1)."""

    def __init__(self):
        # The connection will be set externally during application startup
        self.redis_client: Optional[redis.Redis] = None
        # R3.1: TTL for the idempotency key (5 minutes default)
        self.ttl = settings.IDEMPOTENCY_WINDOW_SECONDS

    def initialize_client(self):
        """Initializes the Redis client for use by this service.

        Prefer a full REDIS_URL (handles auth). Fall back to host/port/db.
        """
        if not self.redis_client:
            # prefer explicit REDIS_URL if provided (handles password)
            url = getattr(settings, "REDIS_URL", None)
            if not url:
                host = os.getenv("REDIS_HOST", settings.REDIS_HOST)
                port = os.getenv("REDIS_PORT", str(settings.REDIS_PORT))
                db = os.getenv("REDIS_DB", str(settings.REDIS_DB))
                pwd = (
                    os.getenv("REDIS_PASSWORD")
                    or os.getenv("REDIS_PASS")
                    or settings.REDIS_PASSWORD
                )
                if pwd:
                    url = f"redis://:{pwd}@{host}:{port}/{db}"
                else:
                    url = f"redis://{host}:{port}/{db}"

            self.redis_client = redis.from_url(
                url,
                encoding="utf-8",
                decode_responses=True,
            )

    def set_client(self, client: redis.Redis):
        """Attach an already-initialized Redis client (useful to share a single connection)."""
        self.redis_client = client

    def get_client(self) -> redis.Redis:
        """Returns the initialized Redis client instance."""
        if not self.redis_client:
            raise RuntimeError(
                "Redis client not initialized. Call initialize_client() first."
            )
        return self.redis_client

    async def check_and_store_idempotency_key(
        self, request_id: str, notification_id: str
    ) -> Tuple[bool, Optional[str]]:
        """
        Check if request_id exists. If it exists, return True and the existing notification_id.
        If not, store the new request_id with the new notification_id and return False.

        Args:
            request_id: The unique ID from the incoming request (the key).
            notification_id: The unique ID generated by the API Gateway (the value).

        Returns:
            A tuple (already_processed: bool, existing_notification_id: str | None).
        """
        key = f"idempotency:{request_id}"
        client = self.get_client()

        # 1. Use Redis transaction/pipeline for atomic operation
        pipeline = client.pipeline()
        pipeline.get(key)
        # SETNX sets the key only if it does NOT exist. We use SET with NX and EX
        # to combine the setting and the TTL atomically, which is safer than SETEX.
        # SET key value NX EX ttl
        pipeline.set(key, notification_id, nx=True, ex=self.ttl)

        results = await pipeline.execute()

        existing_notification_id = results[0]
        was_set_newly = results[1]

        if existing_notification_id:
            # Key already existed (request is a duplicate)
            return (True, existing_notification_id)

        if was_set_newly:
            # Key was set successfully (request is new)
            return (False, None)

        # Edge case: Should not happen if SETNX is used correctly, but ensures return
        return (False, None)


# Create singleton instance (used for initialization and access)
idempotency_service = IdempotencyService()
